//=============================================================================
//
// Code generated by [VAPS XT 4.0.1]
//
//=============================================================================

#ifndef VXTCLSISELLIPSEHASPOLYGON_H
#define VXTCLSISELLIPSEHASPOLYGON_H

//=============================================================================
//                        I N C L U D E   F I L E S
//=============================================================================

#include "vxtBaseClsISEllipseHasPolygon.h"
#include "vxtRTCodedCalculator.h"
#include "vxtRTPropIdPath.h"
#include "vxtRTTopContext.h"
#include "vxtRTTypes.h"
#include "vxtRTValue.h"
#include "vxtTypCoord.h"


//=============================================================================
//                                C L A S S
//=============================================================================

class VXTCLSISELLIPSEHASPOLYGON_SPEC vxtClsISEllipseHasPolygon : public vxtBaseClsISEllipseHasPolygon
{
   
   
public:

 

   
   explicit vxtClsISEllipseHasPolygon(const InitData &a_rInitData);

   virtual ~vxtClsISEllipseHasPolygon();

   virtual void vExecuteOperation(const vxtRTTopContext &a_rTopContext, vxtUShort a_OperationId, const vxtRTValue &a_rOperationData);

private:


	virtual void vUpdate(const vxtRTTopContext &a_rTopContext);

	static vxtBool s_Calculate(vxtTypCoord a_P1, vxtTypCoord a_P2, vxtTypCoord a_P3, vxtTypCoord a_P4, vxtTypCoord a_EllipseCenter, vxtFloat a_ARadius, vxtFloat a_BRadius, vxtFloat mp_Angle);

	static  vxtBool s_CalculateIsLineInEllipse(vxtTypCoord a_POne, vxtTypCoord a_PTwo, vxtTypCoord a_EllipseCenter, vxtFloat a_ARadius, vxtFloat a_BRadius, vxtFloat a_Angle);
	//static vxtBool vxtClsISEllipseHasPolygon::s_CalculateIsCrossTheLines(vxtTypCoord ElP1, vxtTypCoord ElP2, vxtTypCoord LP1, vxtTypCoord LP2);
	static vxtBool vxtClsISEllipseHasPolygon::s_CalculateIsCrossTheLines2(vxtTypCoord ElP1, vxtTypCoord ElP2, vxtTypCoord LP1, vxtTypCoord LP2);
	
	static vxtTypCoord s_FindAnglePoints(vxtTypCoord a_EllipseCenter, vxtFloat a_ARadius, vxtFloat a_BRadius, vxtFloat mp_Angle, vxtFloat mp_AngleG, vxtInt a_flag);


	//static vxtFloat vxtClsISEllipseHasPolygon::Max(vxtFloat a, vxtFloat b);
	//static vxtFloat vxtClsISEllipseHasPolygon::Min(vxtFloat a, vxtFloat b);

	//static vxtBool vxtClsISEllipseHasPolygon::s_CalculateIsPointInEllipse(vxtTypCoord a_Point, vxtTypCoord a_EllipseCenter, vxtFloat a_ARadius, vxtFloat a_BRadius, vxtFloat a_Angle);
	static vxtBool vxtClsISEllipseHasPolygon::s_CalculateIsPointInEllipse2(vxtTypCoord a_Point, vxtTypCoord a_EllipseCenter, vxtFloat a_ARadius, vxtFloat a_BRadius, vxtFloat a_Angle);

   // Disallow copy
   vxtClsISEllipseHasPolygon( const vxtClsISEllipseHasPolygon& );
   vxtClsISEllipseHasPolygon& operator=( const vxtClsISEllipseHasPolygon& );
};


#endif // VXTCLSISELLIPSEHASPOLYGON_H

// END OF FILE

